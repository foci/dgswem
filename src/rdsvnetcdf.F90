MODULE RDSVNETCDF

!**********************************************************************
! BSD SOFTWARE LICENSE
!************************
! PERTAINS TO FORTGRAPHER
!
! COPYRIGHT(c) 2011-2012 EHAB ALI HASSAN:
!*****************************************
! THIS CODE IS DEVELOPED BY: EHAB ALI HASSAN; EHAB@UTEXAS.COM
! RESEARCH ASSISTANT AT UNIVERSITY OF TEXAS AT AUSTIN, TEXAS, US.
! RESEARCH ASSISTANT AT AIN SHAMS UNIVERSITY, CAIRO, EGYPT.
!
! IT IS AN OPEN SOURCE CODE AND YOU ARE ALLOWED TO MAKE ALL REQUIRED CHANGES
! YOU MAY NEED TO THIS CODE BUT YOU HAVE TO SEND ME ALL YOU MODIFICATION AND
! MAKE THESE MODIFICATIONS OPEN FOR ALL OTHERS TO USE FOR FREE.
!
! YOU ARE NOT ALLOWED TO CHANGE THE NAME OF THIS MODULE OR ANY OF ITS
! FUNCTIONS, SUBROUTINES, VARIABLES, ETC.
!
! YOU ARE ALLOWED TO REDISTRIBUTE THIS CODE TO OTHERS WITH THE SAME 
! RESITRICTIONS MENTIONED ABOVE.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are
! met:
!
! - Redistributions of source code must retain the above copyright
!   notice, this list of conditions and the following disclaimer. 
!  
! - Redistributions in binary form must reproduce the above copyright
!   notice, this list of conditions and the following disclaimer listed
!   in this license in the documentation and/or other materials
!   provided with the distribution.
!  
! - Neither the name of the copyright holders nor the names of its
!   contributors may be used to endorse or promote products derived from
!   this software without specific prior written permission.
!  
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
! A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  
! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
!
!
! THIS MODULE CONTAINS SOME SUBROUTINES FOR READING A NETCDF FILE.
! REQUIREMENT:
! (1) FORTRAN 90 COMPILER
! (2) NETCDF LIBRARY FROM http://www.unidata.ucar.edu/downloads/netcdf/index.jsp
! (3) NETCDF FORTRAN F90 FROM http://www.unidata.ucar.edu/downloads/netcdf/index.jsp
!
! SUBROUTINE NETCDF_VAR_NAMES(NETCDF_FILENAME):
! THIS SUBROUTINE RETRIEVES ALL THE VARIABLE NAMES AND THEIR DIMENSIONS ON THE NETCDF FILE
! THIS SUBROUTINE TAKES THE NAME OF THE NETCDF FILE AS AN INPUT AND PRINT THE NAME OF 
! ALL VARIABLES ON THE SCREEN AS AN OUTPUT
!
! SUBROUTINE NETCDF_VAR_NDIMS(NETCDF_FILENAME,VAR_NAME,VAR_NDIMS):
! THIS SUBROUTINE RETRIEVES THE SIZE OF A VARIABLE.
! THIS SUBROUTINE TAKES THE NAME OF A NETCDF FILE AND THE NAME OF A VARIABLE
! (CASE-SENSITIVE) THAT CAN BE OBTAINED FROM SUBROUTINE NETCDF_VAR_NAMES.
! THE OUTPUT IS AN INTEGER(4) THAT HAS THE SIZE OF VARIABLE ARRAY.
!
! SUBROUTINE NETCDF_VAR_DIMS(NETCDF_FILENAME,VAR_NAME,VAR_DIMS):
! THIS SUBROUTINE RETRIEVES THE LENGTH OF EVERY DIMENSION OF A VARIABLE.
! THIS SUBROUTINE TAKES THE NAME OF THE NETCDF FILE AND THE NAME OF A VARIABLE
! (CASE-SENSITIVE) THAT CAN BE OBTAINED FROM SUBROUTINE NETCDF_VAR_NAMES.
! THE OUTPUT IS AN INTEGER(4) ARRAY OF DIMENSION NAME_VAR_NDIMS THAT CAN BE
! OBTAINED FROM SUBROUTINE NETCDF_VAR_NDIMS(NETCDF_FILENAME,VAR_NAME,VAR_NDIMS).
! YOU CAN ALLOCATE THE VAR_DIMS ARRAY USING THE VAR_NDIMS OUTPUT.
!
! SUBROUTINE NETCDF_VAR_1D_GET(NETCDF_FILENAME,VAR_NAME,VAR_MAT)
! THE SUBROUTINE RETRIEVES THE DATA MATRIX OF A VARIABLE.
! THIS SUBROUTINE TAKES THE NAME OF THE NETCDF FILE AND THE NAME OF A VARIABLE
! (CASE-SENSITIVE) THAT CAN BE OBTAINED FROM SUBROUTINE NETCDF_VAR_NAMES.
! THE OUTPUT IS A REAL(4) ARRAY OF DIMENSION NAME_VAR_NDIMS THAT CAN BE
! OBTAINED FROM SUBROUTINE NETCDF_VAR_NDIMS(NETCDF_FILENAME,VAR_NAME,VAR_NDIMS).
! THE LENGTH OF EACH DIMENSION IS OBTAINED FROM CALLING THE
! SUBROUTINE NETCDF_VAR_DIMS(NETCDF_FILENAME,VAR_NAME,VAR_DIMS).
! THEN YOU CAN ALLOCATE THE VAR_MAT USING THE VALUES IN THE VAR_DIMS ARRAY.
! subroutine handle_err(status,VarID)
! THIS SUBROUTINE RETRIEVES THE ERRORS IN CALLING ANY NETCDF SUBROUTINE.
! SO IT CAN HANDLE ALL THE ERRORS.
!
! SUBROUTINE SAVEDIMS3D(NETCDFFNAME,X1D,Y1D,Z1D,DIMNAMES,DIMUNITS)
! SUBROUTINE SAVEDIMS2D(NETCDFFNAME,X1D,Y1D,DIMNAMES,DIMUNITS)
! SUBROUTINE SAVEDIMS1D(NETCDFFNAME,X1D,DIMNAMES,DIMUNITS)
! THESE SUBROUTINES ARE DESIGNED TO SAVE THE DIMENSIONS IN CASE OF
! 1D, 2D, OR 3D.
! THE TIME IS ALWAYS THEIR AND YOU NEED TO INCLUDE ITS NAME AND UNIT
! IN DIMNAMES AND DIMUNITS, RESPECTIVELY.
! DIMNAMES AND DIMUNITS ARE CHARACTER ARRAYS OF DIMENSION EQUALS THE
! SYSTEM DIMENSION+1. FOR EXAMPLE: IF THE SYSTEM DIMENSION IS 1D, THE 
! DIMENSION OF BOTH DIMNAMES AND DIMUNITS IS 2D.
! NETCDFFNAME IS A CHARACTER VARIABLE FOR THE NETCDF FILENAME.
! THE SUBROUTINES TAKE REAL(4) OR REAL(8) FOR X1D, Y1D, AND Z1D.
!
!

 USE NETCDF

 INTERFACE NETCDF_VAR_GET
  MODULE PROCEDURE NETCDF_VAR_1D_GET,NETCDF_VAR_2D_GET,NETCDF_VAR_3D_GET,NETCDF_VAR_4D_GET
 END INTERFACE NETCDF_VAR_GET

!INTERFACE GETVARINFO
! MODULE PROCEDURE GETVARINFOID,GETVARINFONM
!END INTERFACE GETVARINFO

 INTERFACE DEFNEWDIM
  MODULE PROCEDURE DEFNEWLDIM,DEFNEWULDIM
 END INTERFACE DEFNEWDIM

 INTERFACE DEFNEWFLD
  MODULE PROCEDURE DEFNEWFLDSWNDIMS,DEFNEWFLDWNDIMS,DEFNEWFLDWDIMINDX
 END INTERFACE DEFNEWFLD

 INTERFACE SAVEDIM
  MODULE PROCEDURE i4SAVEDIM0D,r4SAVEDIM0D,r8SAVEDIM0D, &
                   i4SAVEDIM1D,r4SAVEDIM1D,r8SAVEDIM1D
 END INTERFACE SAVEDIM

 INTERFACE RECORDTIME
  MODULE PROCEDURE r4RECORDTIME,r8RECORDTIME
 END INTERFACE RECORDTIME

 INTERFACE SAVEFLD
  MODULE PROCEDURE i4SAVEFLD4D,r4SAVEFLD4D,r8SAVEFLD4D, &
                   i4SAVEFLD3D,r4SAVEFLD3D,r8SAVEFLD3D, &
                   i4SAVEFLD2D,r4SAVEFLD2D,r8SAVEFLD2D, &
                   i4SAVEFLD1D,r4SAVEFLD1D,r8SAVEFLD1D, &
                   i4SAVEFLD0D,r4SAVEFLD0D,r8SAVEFLD0D
 END INTERFACE SAVEFLD

 INTERFACE READDIM
  MODULE PROCEDURE i4READDIM,r4READDIM,r8READDIM
 END INTERFACE READDIM

 INTERFACE READFLD
  MODULE PROCEDURE i4READFLD4D,r4READFLD4D,r8READFLD4D, &
                   i4READFLD3D,r4READFLD3D,r8READFLD3D, &
                   i4READFLD2D,r4READFLD2D,r8READFLD2D, &
                   i4READFLD1D,r4READFLD1D,r8READFLD1D, &
                   i4READFLD0D,r4READFLD0D,r8READFLD0D
 END INTERFACE READFLD

 INTERFACE NUM2STR
  MODULE PROCEDURE I4NUM2STR
 END INTERFACE NUM2STR

 CONTAINS

SUBROUTINE NETCDFGINFO(NETCDF_FILENAME,nDIMS,nVARS,nGLOBALATTS)
 IMPLICIT NONE
!***************** INPUT VARIABLES DECLARATION ***************
 INTEGER(4),INTENT(OUT),OPTIONAL   :: nDims, nVars, nGlobalAtts
 CHARACTER(*),INTENT(IN) :: NETCDF_FILENAME
!**************** LOCAL VARIABLES DECLARATION *****************
 INTEGER(4)   :: status, ncid
!INTEGER(4)   :: unlimDimID

 status = NF90_OPEN(TRIM(NETCDF_FILENAME), nf90_NoWrite, ncid )
 !status = nf90_inquire(ncid, nDims, nVars, nGlobalAtts, unlimdimid)
 IF(PRESENT(nGLOBALATTS)) THEN
  status = nf90_inquire(ncid, nDims, nVars, nGlobalAtts)
 ELSE IF(PRESENT(nVARS)) THEN
  status = nf90_inquire(ncid, nDims, nVars)
 ELSE IF(PRESENT(nDIMS)) THEN
  status = nf90_inquire(ncid, nDims)
 END IF
 status = NF90_CLOSE(ncid )

 RETURN
END SUBROUTINE NETCDFGINFO


SUBROUTINE NETCDF_VAR_NAMES(NETCDF_FILENAME)
 IMPLICIT NONE
!***************** INPUT VARIABLES DECLARATION ***************
 CHARACTER(*),INTENT(IN) :: NETCDF_FILENAME
!**************** LOCAL VARIABLES DECLARATION *****************
 CHARACTER(100):: varNAME
 INTEGER(4)   :: NETCDF_ID
 INTEGER(4)   :: nDims, nVars, nGlobalAtts
 INTEGER(4)   :: status, unlimDimID
 INTEGER(4)   :: I

 status = NF90_OPEN(TRIM(NETCDF_FILENAME), nf90_NoWrite, ncid = NETCDF_ID)
 status = nf90_inquire(NETCDF_ID, nDims, nVars, nGlobalAtts, unlimdimid)
 do I=1,nVars
  status = nf90_inquire_variable(ncid = NETCDF_ID, varID = I, name = varNAME, ndims = nDims)
  print*, I, ":", TRIM(varName), "(n_dims = ", char(48+nDims) ,")"
 end do
 status = NF90_CLOSE(ncid = NETCDF_ID)

 RETURN
END SUBROUTINE NETCDF_VAR_NAMES


SUBROUTINE NETCDF_VAR_NDIMS(NETCDF_FILENAME,VAR_NAME,VAR_NDIMS)
 IMPLICIT NONE
 CHARACTER(*) :: NETCDF_FILENAME,VAR_NAME
 INTEGER(4)   :: NETCDF_ID,VAR_ID,VAR_NDIMS
 INTEGER(4)   :: status

 status = NF90_OPEN(TRIM(NETCDF_FILENAME), nf90_NoWrite, ncid = NETCDF_ID)
 status = nf90_inq_varid(ncid = NETCDF_ID, name = VAR_NAME, varid = VAR_ID)
 status = nf90_inquire_variable(ncid = NETCDF_ID, varID = VAR_ID , ndims = VAR_NDIMS)
 status = NF90_CLOSE(ncid = NETCDF_ID)

 RETURN
END SUBROUTINE NETCDF_VAR_NDIMS


SUBROUTINE NETCDF_VAR_DIMS(NETCDF_FILENAME,VAR_NAME,VAR_DIMS)
 IMPLICIT NONE
 CHARACTER(*) :: NETCDF_FILENAME,VAR_NAME
 INTEGER(4)   :: dimIDs(nf90_max_var_dims)
 INTEGER(4)   :: NETCDF_ID,VAR_ID,VAR_DIMS(:)
 INTEGER(4)   :: status, nDims
 INTEGER(4)   :: I

 status = NF90_OPEN(TRIM(NETCDF_FILENAME), nf90_NoWrite, ncid = NETCDF_ID)
 status = nf90_inq_varid(ncid = NETCDF_ID, name = VAR_NAME, varid = VAR_ID)
 status = nf90_inquire_variable(ncid = NETCDF_ID, varID = VAR_ID , dimids = dimIDs)
 do I=1,SIZE(VAR_DIMS)
  status = nf90_inquire_dimension(ncid = NETCDF_ID, dimid = dimIDs(I), len = VAR_DIMS(I))
 end do
 status = NF90_CLOSE(ncid = NETCDF_ID)

 RETURN
END SUBROUTINE NETCDF_VAR_DIMS

SUBROUTINE NETCDF_VAR_1D_GET(NETCDF_FILENAME,VAR_NAME,VAR_MAT)
 IMPLICIT NONE
 CHARACTER(*) :: NETCDF_FILENAME,VAR_NAME
 INTEGER(4)   :: NETCDF_ID,VAR_ID
 INTEGER(4)   :: status
 REAL(4)      :: VAR_MAT(:)

 status = NF90_OPEN(TRIM(NETCDF_FILENAME), nf90_NoWrite, ncid = NETCDF_ID)
 status = nf90_inq_varid(ncid = NETCDF_ID, name = VAR_NAME, varid = VAR_ID)
 status = nf90_get_var(NETCDF_ID, VAR_ID, VAR_MAT)
 status = NF90_CLOSE(ncid = NETCDF_ID)

 RETURN
END SUBROUTINE NETCDF_VAR_1D_GET


SUBROUTINE NETCDF_VAR_2D_GET(NETCDF_FILENAME,VAR_NAME,VAR_MAT)
 IMPLICIT NONE
 CHARACTER(*) :: NETCDF_FILENAME,VAR_NAME
 INTEGER(4)   :: NETCDF_ID,VAR_ID
 INTEGER(4)   :: status
 REAL(4)      :: VAR_MAT(:,:)

 status = NF90_OPEN(TRIM(NETCDF_FILENAME), nf90_NoWrite, ncid = NETCDF_ID)
 status = nf90_inq_varid(ncid = NETCDF_ID, name = VAR_NAME, varid = VAR_ID)
 status = nf90_get_var(NETCDF_ID, VAR_ID, VAR_MAT)
 status = NF90_CLOSE(ncid = NETCDF_ID)

 RETURN
END SUBROUTINE NETCDF_VAR_2D_GET


SUBROUTINE NETCDF_VAR_3D_GET(NETCDF_FILENAME,VAR_NAME,VAR_MAT)
 IMPLICIT NONE
 CHARACTER(*) :: NETCDF_FILENAME,VAR_NAME
 INTEGER(4)   :: NETCDF_ID,VAR_ID
 INTEGER(4)   :: status
 REAL(4)      :: VAR_MAT(:,:,:)

 status = NF90_OPEN(TRIM(NETCDF_FILENAME), nf90_NoWrite, ncid = NETCDF_ID)
 status = nf90_inq_varid(ncid = NETCDF_ID, name = VAR_NAME, varid = VAR_ID)
 status = nf90_get_var(NETCDF_ID, VAR_ID, VAR_MAT)
 status = NF90_CLOSE(ncid = NETCDF_ID)

 RETURN
END SUBROUTINE NETCDF_VAR_3D_GET

SUBROUTINE NETCDF_VAR_4D_GET(NETCDF_FILENAME,VAR_NAME,VAR_MAT)
 IMPLICIT NONE
 CHARACTER(*) :: NETCDF_FILENAME,VAR_NAME
 INTEGER(4)   :: NETCDF_ID,VAR_ID
 INTEGER(4)   :: status
 REAL(4)      :: VAR_MAT(:,:,:,:)

 status = NF90_OPEN(TRIM(NETCDF_FILENAME), nf90_NoWrite, ncid = NETCDF_ID)
 status = nf90_inq_varid(ncid = NETCDF_ID, name = VAR_NAME, varid = VAR_ID)
 status = nf90_get_var(NETCDF_ID, VAR_ID, VAR_MAT)
 status = NF90_CLOSE(ncid = NETCDF_ID)

 RETURN
END SUBROUTINE NETCDF_VAR_4D_GET



!********************************************!
! SAVE THE FIELDS AND DIMENSIONS TO A NETCDF !
!********************************************!
!*********************!
! CREATE A NEW NETCDF !
!*********************!
 SUBROUTINE CREATECDF(NCID,NETCDFFNAME,MPICOMMWORLD,MPIINFONULL)
  IMPLICIT NONE
  CHARACTER(*), INTENT(IN)  :: NETCDFFNAME
  INTEGER(4),   INTENT(OUT) :: NCID
  INTEGER(4),   OPTIONAL    :: MPICOMMWORLD,MPIINFONULL
  INTEGER(4)                :: mode_flag

  IF(PRESENT(MPICOMMWORLD).AND.PRESENT(MPIINFONULL)) THEN
    mode_flag = IOR(NF90_CLOBBER, nf90_netcdf4) 
    mode_flag = IOR(mode_flag, nf90_classic_model) 
    mode_flag = IOR(mode_flag, nf90_mpiio)
    call check( nf90_create(TRIM(NETCDFFNAME), mode_flag, ncid, comm = MPICOMMWORLD, info = MPIINFONULL) )
  ELSE
    call check( nf90_create(TRIM(NETCDFFNAME), nf90_clobber, ncid) )
  END IF

  RETURN
 END SUBROUTINE CREATECDF

!***************!
! OPEN A NETCDF !
!***************!
 SUBROUTINE OPENCDFTOWRITE(NCID,NETCDFFNAME,MPICOMMWORLD,MPIINFONULL)
  IMPLICIT NONE
  CHARACTER(*), INTENT(IN)  :: NETCDFFNAME
  INTEGER(4),   INTENT(OUT) :: NCID
  INTEGER(4),   OPTIONAL    :: MPICOMMWORLD,MPIINFONULL
  INTEGER(4)                :: mode_flag

  IF(PRESENT(MPICOMMWORLD).AND.PRESENT(MPIINFONULL)) THEN
    mode_flag = IOR(nf90_write, nf90_netcdf4)
    mode_flag = IOR(mode_flag, nf90_classic_model) 
    mode_flag = IOR(mode_flag, nf90_mpiio)
    CALL check(nf90_open(TRIM(NETCDFFNAME), mode_flag, ncid, comm = MPICOMMWORLD, info = MPIINFONULL))
  ELSE
    CALL check(nf90_open(NETCDFFNAME, nf90_write, ncid))
  END IF

  RETURN
 END SUBROUTINE OPENCDFTOWRITE

 SUBROUTINE OPENCDFTOREAD(NCID,NETCDFFNAME,MPICOMMWORLD,MPIINFONULL)
  IMPLICIT NONE
  CHARACTER(*), INTENT(IN)  :: NETCDFFNAME
  INTEGER(4),   INTENT(OUT) :: NCID
  INTEGER(4),   OPTIONAL    :: MPICOMMWORLD,MPIINFONULL
  INTEGER(4)                :: mode_flag

  IF(PRESENT(MPICOMMWORLD).AND.PRESENT(MPIINFONULL)) THEN
    mode_flag = IOR(nf90_nowrite, nf90_netcdf4)
    mode_flag = IOR(mode_flag, nf90_classic_model) 
    mode_flag = IOR(mode_flag, nf90_mpiio)
    CALL check(nf90_open(TRIM(NETCDFFNAME), mode_flag, ncid, comm = MPICOMMWORLD, info = MPIINFONULL))
  ELSE
    CALL check(nf90_open(TRIM(NETCDFFNAME), nf90_nowrite, ncid))
  END IF

  RETURN
 END SUBROUTINE OPENCDFTOREAD

!****************!
! CLOSE A NETCDF !
!****************!
 SUBROUTINE CLOSECDF(NCID)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN) :: NCID

  CALL check( nf90_close(ncid) )

  RETURN
 END SUBROUTINE CLOSECDF

!***************************************!
! DEFINE NEW DIMENSIONS TO A NETCDF FILE!
!***************************************!
 ! DEFINE NEW DIMENSION OF KNOWN LIMITED SIZE
 SUBROUTINE DEFNEWLDIM(NCID,DIMNAME,DIMUNIT,XSIZE,XVARID,XDIMID)
  IMPLICIT NONE
  INTEGER(4),  INTENT(IN)  :: NCID
  INTEGER(4),  INTENT(IN)  :: XSIZE
  INTEGER(4),  INTENT(OUT) :: XVARID
  INTEGER(4),  INTENT(OUT) :: XDIMID
  CHARACTER(*)             :: DIMNAME
  CHARACTER(*)             :: DIMUNIT

  !LOCAL VARIABLE
  INTEGER(4)               :: iostatus

  !start re-Define mode.
  iostatus = nf90_redef(NCID)
  !Define the dimensions.
  call check( nf90_def_dim(ncid, TRIM(DIMNAME), XSIZE,       XDIMID) )
  !Define the coordinate variables.
  call check( nf90_def_var(ncid, TRIM(DIMNAME), NF90_DOUBLE, XDIMID, XVARID))
  !Assign units attributes to coordinate variables.
  call check( nf90_put_att(ncid, XVARID, "units", TRIM(DIMUNIT)) )
 !End define mode.
  call check( nf90_enddef(ncid) )

  RETURN
 END SUBROUTINE DEFNEWLDIM

 ! DEFINE NEW DIMENSION OF UNLIMITED SIZE
 SUBROUTINE DEFNEWULDIM(NCID,DIMNAME,DIMUNIT,XVARID,XDIMID)
  IMPLICIT NONE
  INTEGER(4),  INTENT(IN)  :: NCID
  INTEGER(4),  INTENT(OUT) :: XVARID
  INTEGER(4),  INTENT(OUT) :: XDIMID
  CHARACTER(*)             :: DIMNAME
  CHARACTER(*)             :: DIMUNIT

  !LOCAL VARIABLE
  INTEGER(4)               :: iostatus

  !start re-Define mode.
  iostatus = nf90_redef(NCID)
  !The record dimension is defined to have unlimited length - it can grow as needed.
  call check( nf90_def_dim(ncid, TRIM(DIMNAME), NF90_UNLIMITED, XDIMID) )
  !Define the coordinate variables.
  call check( nf90_def_var(ncid, TRIM(DIMNAME), NF90_DOUBLE, XDIMID, XVARID))
  !Assign units attributes to coordinate variables.
  call check( nf90_put_att(ncid, XVARID, "units", TRIM(DIMUNIT)) )
 !End define mode.
  call check( nf90_enddef(ncid) )

  RETURN
 END SUBROUTINE DEFNEWULDIM

!*************************************!
! SAVE NEW DIMENSION TO A NETCDF FILE !
!*************************************!
 SUBROUTINE i4SAVEDIM0D(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN) :: X1D
  INTEGER(4),   INTENT(IN) :: NCID
  INTEGER(4),   INTENT(IN) :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D,DATASTART)
  ELSE
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D)
  ENDIF

  RETURN
 END SUBROUTINE i4SAVEDIM0D

 SUBROUTINE i4SAVEDIM1D(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN) :: X1D(:)
  INTEGER(4),   INTENT(IN) :: NCID
  INTEGER(4),   INTENT(IN) :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D,DATASTART)
  ELSE
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D)
  ENDIF

  RETURN
 END SUBROUTINE i4SAVEDIM1D

 SUBROUTINE r4SAVEDIM0D(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),      INTENT(IN) :: X1D
  INTEGER(4),   INTENT(IN) :: NCID
  INTEGER(4),   INTENT(IN) :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D,DATASTART)
  ELSE
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D)
  ENDIF

  RETURN
 END SUBROUTINE r4SAVEDIM0D

 SUBROUTINE r4SAVEDIM1D(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),      INTENT(IN) :: X1D(:)
  INTEGER(4),   INTENT(IN) :: NCID
  INTEGER(4),   INTENT(IN) :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D,DATASTART)
  ELSE
    CALL SAVEDIM(NCID,XVARID,1.0d0*X1D)
  ENDIF

  RETURN
 END SUBROUTINE r4SAVEDIM1D

 SUBROUTINE r8SAVEDIM0D(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),      INTENT(IN) :: X1D
  INTEGER(4),   INTENT(IN) :: NCID
  INTEGER(4),   INTENT(IN) :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

 !Write the coordinate variable data.
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    call check( nf90_var_par_access(ncid, XVARID, nf90_collective) )
    call check( nf90_put_var(NCID,XVARID,(/X1D/), start = (/DATASTART/), count = (/DATACOUNT/)) )
  ELSE IF(PRESENT(DATASTART)) THEN
    call check( nf90_var_par_access(ncid, XVARID, nf90_collective) )
    call check( nf90_put_var(NCID,XVARID,(/X1D/), start = (/DATASTART/), count = (/1/)) )
  ELSE
    call check( nf90_put_var(NCID,XVARID,(/X1D/)) )
  ENDIF

  RETURN
 END SUBROUTINE r8SAVEDIM0D

 SUBROUTINE r8SAVEDIM1D(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),      INTENT(IN) :: X1D(:)
  INTEGER(4),   INTENT(IN) :: NCID
  INTEGER(4),   INTENT(IN) :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

 !Write the coordinate variable data.
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    call check( nf90_var_par_access(ncid, XVARID, nf90_collective) )
    call check( nf90_put_var(NCID,XVARID,X1D, start = (/DATASTART/), count = (/DATACOUNT/)) )
  ELSE IF(PRESENT(DATASTART)) THEN
    call check( nf90_var_par_access(ncid, XVARID, nf90_collective) )
    call check( nf90_put_var(NCID,XVARID,X1D, start = (/DATASTART/), count = (/SIZE(X1D)/)) )
  ELSE
    call check( nf90_put_var(NCID,XVARID,X1D) )
  ENDIF

  RETURN
 END SUBROUTINE r8SAVEDIM1D


!*******************************!
!          RECORD TIME          !
!*******************************!
 SUBROUTINE r4RECORDTIME(NCID,RECID,RECTIME,TVARID)
  IMPLICIT NONE
  REAL(4),      INTENT(IN)    :: RECTIME
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: TVARID

  call check( nf90_var_par_access(ncid, TVARID, nf90_collective) )
  call check( nf90_put_var(ncid, TVARID, RECTIME, start = (/RECID/)) )

  RETURN
 END SUBROUTINE r4RECORDTIME

 SUBROUTINE r8RECORDTIME(NCID,RECID,RECTIME,TVARID)
  IMPLICIT NONE
  REAL(8),      INTENT(IN)    :: RECTIME
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: TVARID

  call check( nf90_var_par_access(ncid, TVARID, nf90_collective) )
  call check( nf90_put_var(ncid, TVARID, RECTIME, start = (/RECID/)) )

  RETURN
 END SUBROUTINE r8RECORDTIME

!*******************************!
! DEFINE NEW FIELDS TO A NETCDF !
!*******************************!
 SUBROUTINE DEFNEWFLDWDIMINDX(NCID,DIMIDS,FLDNAME,FLDUNIT,FLDVARID)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)  :: DIMIDS(:)
  INTEGER(4),   INTENT(IN)  :: NCID
  INTEGER(4),   INTENT(OUT) :: FLDVARID
  CHARACTER(*), INTENT(IN)  :: FLDNAME
  CHARACTER(*), INTENT(IN)  :: FLDUNIT

  !LOCAL VARIABLES
  INTEGER(4)                  :: iostate


  !check if the field is already defined before
  iostate = nf90_inq_varid(ncid,TRIM(FLDNAME),FLDVARID)
  IF(iostate.ne.nf90_noerr) THEN
  !start re-Define mode.
   call check(nf90_redef(NCID) )
  !Define the netCdF variables.
   call check( nf90_def_var(NCID,TRIM(FLDNAME),NF90_DOUBLE,DIMIDS,FLDVARID) )
  !Assign units attributes to the netCDF variables.
   call check( nf90_put_att(ncid, FLDVARID, "units", TRIM(FLDUNIT)) )
  !End define mode.
   call check( nf90_enddef(ncid) )
  END IF

  RETURN
 END SUBROUTINE DEFNEWFLDWDIMINDX

 SUBROUTINE DEFNEWFLDWNDIMS(NCID,NDIMS,FLDNAME,FLDUNIT,FLDVARID)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)  :: NDIMS
  INTEGER(4),   INTENT(IN)  :: NCID
  INTEGER(4),   INTENT(OUT) :: FLDVARID
  CHARACTER(*), INTENT(IN)  :: FLDNAME
  CHARACTER(*), INTENT(IN)  :: FLDUNIT

  !LOCAL VARIABLES
  INTEGER(4),ALLOCATABLE      :: dimids(:)
  INTEGER(4)                  :: iostate


  !check if the field is already defined before
  iostate = nf90_inq_varid(ncid,TRIM(FLDNAME),FLDVARID)
  IF(iostate.ne.nf90_noerr) THEN
   !start re-Define mode.
   call check(nf90_redef(NCID) )
   !allocate the dimensions ids
   ALLOCATE(dimids(NDIMS+1))
   IF(NDIMS.EQ.3) THEN
    dimids = (/ 1, 2, 3, 4 /)
   ELSE IF(NDIMS.EQ.2) THEN
    dimids = (/ 1, 2, 3 /)
   ELSE IF(NDIMS.EQ.1) THEN
    dimids = (/ 1, 2 /)
   END IF
   !Define the netCdF variables.
   call check( nf90_def_var(NCID,TRIM(FLDNAME),NF90_DOUBLE,dimids,FLDVARID) )
   !Assign units attributes to the netCDF variables.
   call check( nf90_put_att(ncid, FLDVARID, "units", TRIM(FLDUNIT)) )
   !End define mode.
   call check( nf90_enddef(ncid) )
  END IF

  RETURN
 END SUBROUTINE DEFNEWFLDWNDIMS

 SUBROUTINE DEFNEWFLDSWNDIMS(NETCDFFNAME,NDIMS,FLDSNAME,FLDSUNIT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)    :: NDIMS
  CHARACTER(*), INTENT(IN)    :: NETCDFFNAME
  CHARACTER(*), INTENT(INOUT) :: FLDSNAME(:)
  CHARACTER(*), INTENT(INOUT) :: FLDSUNIT(:)

 !NETCDF INPUTS VARIABLES
  INTEGER(4)                  :: NCID
  CHARACTER(5)                :: UNITS    = "units"

 !CHARACTER(50),ALLOCATABLE :: FLDNAMES(:),FLDUNITS(:)
  INTEGER(4),ALLOCATABLE      :: dimids(:)
  INTEGER(4)                  :: FLDVARID

  !LOOP INDICES
  INTEGER(4)                  :: iostate
  INTEGER(4)                  :: nflds,ifld

  nflds=SIZE(FLDSNAME)

  CALL check(nf90_open(NETCDFFNAME, nf90_write, ncid))
  !start re-Define mode.
  call check(nf90_redef(ncid) )
  !allocate the dimensions ids
  ALLOCATE(dimids(NDIMS+1))

  IF(NDIMS.EQ.3) THEN
   dimids = (/ 1, 2, 3, 4 /)
  ELSE IF(NDIMS.EQ.2) THEN
   dimids = (/ 1, 2, 3 /)
  ELSE IF(NDIMS.EQ.1) THEN
   dimids = (/ 1, 2 /)
  END IF
  DO ifld=1,nflds
   !check if the field is already defined before
   iostate = nf90_inq_varid(ncid, TRIM(FLDSNAME(ifld)), FLDVARID)
   IF(iostate.eq.nf90_noerr) THEN
    PRINT*, "A FIELD WITH THE SAME NAME ("//TRIM(FLDSNAME(ifld))// ") IS ALREADY EXIST!"
    CONTINUE
   END IF
   !Define the netCdF variables.
   call check( nf90_def_var(ncid, TRIM(FLDSNAME(ifld)), NF90_DOUBLE, dimids, FLDVARID) )
   !Assign units attributes to the netCDF variables.
   call check( nf90_put_att(ncid, FLDVARID, UNITS, TRIM(FLDSUNIT(ifld))) )
  END DO
  !End define mode.
  call check( nf90_enddef(ncid) )

  RETURN
 END SUBROUTINE DEFNEWFLDSWNDIMS


!*************************!
! SAVE 3D MULTIPLE FIELDS !
!*************************!
 SUBROUTINE i4SAVEFLD4D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)    :: rfld(:,:,:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID(:)
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
  ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE i4SAVEFLD4D

 SUBROUTINE r4SAVEFLD4D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),      INTENT(IN)    :: rfld(:,:,:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID(:)
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
  ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE r4SAVEFLD4D

 SUBROUTINE r8SAVEFLD4D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),      INTENT(IN)    :: rfld(:,:,:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID(:)
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  INTEGER(4), PARAMETER       :: NDIMS    = 4
  INTEGER(4)                  :: start(NDIMS), count(NDIMS)
  INTEGER(4)                  :: MATDIMS4D(4),ifld


  MATDIMS4D=SHAPE(rfld)
  !These settings tell netcdf to write one timestep of data.
  IF(PRESENT(DATACOUNT)) THEN
   count(1:NDIMS-1) = DATACOUNT
   count(NDIMS)     = 1
  ELSE
   count = (/ MATDIMS4D(1), MATDIMS4D(2), MATDIMS4D(3), 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(1:NDIMS-1) = DATASTART
   start(NDIMS)     = RECID
  ELSE
   start = (/ 1, 1, 1, RECID /)
  END IF

  !record the data.
  DO ifld=1,MATDIMS4D(4)
   call check( nf90_var_par_access(ncid, FLDVARID(ifld), nf90_collective) )
   call check( nf90_put_var(ncid, FLDVARID(ifld), rfld(:,:,:,ifld), start = start, count = count) )
  END DO
  
  RETURN
 END SUBROUTINE r8SAVEFLD4D

!**********************!
! SAVE 3D SINGLE FIELD !
!**********************!
 SUBROUTINE i4SAVEFLD3D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)    :: rfld(:,:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
   ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE i4SAVEFLD3D

 SUBROUTINE r4SAVEFLD3D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),      INTENT(IN)    :: rfld(:,:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
   ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE r4SAVEFLD3D

 SUBROUTINE r8SAVEFLD3D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),      INTENT(IN)    :: rfld(:,:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

 !LOCAL VARIABLES
  INTEGER(4), PARAMETER       :: NDIMS    = 4
  INTEGER(4)                  :: start(NDIMS), count(NDIMS)
  INTEGER(4)                  :: MATDIMS3D(3)


  !These settings tell netcdf to write one timestep of data.
  IF(PRESENT(DATACOUNT)) THEN
   count(1:NDIMS-1) = DATACOUNT
   count(NDIMS)     = 1
  ELSE
   MATDIMS3D=SHAPE(rfld)
   count = (/ MATDIMS3D(1), MATDIMS3D(2), MATDIMS3D(3), 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(1:NDIMS-1) = DATASTART
   start(NDIMS)     = RECID
  ELSE
   start = (/ 1, 1, 1, RECID /)
  END IF

  !record the data.
  call check( nf90_var_par_access(ncid, FLDVARID, nf90_collective) )
  call check( nf90_put_var(ncid, FLDVARID, rfld, start = start, count = count) )

  RETURN
 END SUBROUTINE r8SAVEFLD3D

!**********************!
! SAVE 2D SINGLE FIELD !
!**********************!
 SUBROUTINE i4SAVEFLD2D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)    :: rfld(:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
  ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE i4SAVEFLD2D

 SUBROUTINE r4SAVEFLD2D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),      INTENT(IN)    :: rfld(:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
  ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE r4SAVEFLD2D

 SUBROUTINE r8SAVEFLD2D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),      INTENT(IN)    :: rfld(:,:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  INTEGER(4), PARAMETER       :: NDIMS    = 3
  INTEGER(4)                  :: start(NDIMS), count(NDIMS)
  INTEGER(4)                  :: MATDIMS2D(2)


  !These settings tell netcdf to write one timestep of data.
  IF(PRESENT(DATACOUNT)) THEN
   count(1:NDIMS-1) = DATACOUNT
   count(NDIMS)     = 1
  ELSE
   MATDIMS2D=SHAPE(rfld)
   count = (/ MATDIMS2D(1), MATDIMS2D(2), 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(1:NDIMS-1) = DATASTART
   start(NDIMS)     = RECID
  ELSE
   start = (/ 1, 1, RECID /)
  END IF

  !record the data.
  call check( nf90_var_par_access(ncid, FLDVARID, nf90_collective) )
  call check( nf90_put_var(ncid, FLDVARID, rfld, start = start, count = count) )

  RETURN
 END SUBROUTINE r8SAVEFLD2D

!**********************!
! SAVE 1D SINGLE FIELD !
!**********************!
 SUBROUTINE i4SAVEFLD1D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)    :: rfld(:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4)                  :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART,DATACOUNT

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
  ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE i4SAVEFLD1D

 SUBROUTINE r4SAVEFLD1D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),      INTENT(IN)    :: rfld(:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART,DATACOUNT

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
  ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE r4SAVEFLD1D

 SUBROUTINE r8SAVEFLD1D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),      INTENT(IN)    :: rfld(:)
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART,DATACOUNT

  !LOCAL VARIABLES
  INTEGER(4), PARAMETER       :: NDIMS    = 2
  INTEGER(4)                  :: start(NDIMS), count(NDIMS)
  INTEGER(4)                  :: MATDIMS1D(1)


  !These settings tell netcdf to write one timestep of data.
  IF(PRESENT(DATACOUNT)) THEN
   count(1:NDIMS-1) = DATACOUNT
   count(NDIMS)     = 1
  ELSE
   MATDIMS1D=SIZE(rfld)
   count = (/ MATDIMS1D(1), 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(1:NDIMS-1) = DATASTART
   start(NDIMS)     = RECID
  ELSE
   start = (/ 1, RECID /)
  END IF

  !record the data.
  call check( nf90_var_par_access(ncid, FLDVARID, nf90_collective) )
  call check( nf90_put_var(ncid, FLDVARID, rfld, start = start, count = count) )

  RETURN
 END SUBROUTINE r8SAVEFLD1D

!**********************!
! SAVE 0D SINGLE FIELD !
!**********************!
 SUBROUTINE i4SAVEFLD0D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)    :: rfld
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART,DATACOUNT

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
  ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE i4SAVEFLD0D

 SUBROUTINE r4SAVEFLD0D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),      INTENT(IN)    :: rfld
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART,DATACOUNT

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID,DATASTART)
  ELSE
    CALL SAVEFLD(NCID,RECID,1.0d0*rfld,FLDVARID)
  END IF

  RETURN
 END SUBROUTINE r4SAVEFLD0D

 SUBROUTINE r8SAVEFLD0D(NCID,RECID,rfld,FLDVARID,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),      INTENT(IN)    :: rfld
  INTEGER(4),   INTENT(IN)    :: RECID
  INTEGER(4),   INTENT(IN)    :: NCID
  INTEGER(4),   INTENT(IN)    :: FLDVARID
  INTEGER(4),   OPTIONAL      :: DATASTART,DATACOUNT

  !LOCAL VARIABLES
  INTEGER(4), PARAMETER       :: NDIMS    = 1
  INTEGER(4)                  :: start(NDIMS), count(NDIMS)


  !These settings tell netcdf to write one timestep of data.
  IF(PRESENT(DATACOUNT)) THEN
   count(NDIMS)     = 1
  ELSE
   count = (/ 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(NDIMS)     = RECID
  ELSE
   start = (/ RECID /)
  END IF

  !record the data.
  call check( nf90_var_par_access(ncid, FLDVARID, nf90_collective) )
  call check( nf90_put_var(ncid, FLDVARID, (/rfld/), start = start, count = count) )

  RETURN
 END SUBROUTINE r8SAVEFLD0D

!*****************************************************!
! GET INFORMATION ABOUT A VARIABLE FROM A NETCDF FILE !
!*****************************************************!
! GET INFORMATION ABOUT A VARIABLE FROM A NETCDF FILE !
!*****************************************************!
 SUBROUTINE GETVARINFO(NCID,VARID,VARNDIMS,VARNAME,VARUNIT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)              :: NCID
  INTEGER(4),   INTENT(OUT)             :: VARNDIMS
  INTEGER(4),   INTENT(INOUT)           :: VARID
  CHARACTER(*), INTENT(INOUT)           :: VARNAME
  CHARACTER(*), INTENT(OUT),   OPTIONAL :: VARUNIT


  IF((VARID.NE.0).AND.(TRIM(VARNAME).EQ."")) THEN
    !GET VARIABLE NAME
    call check( nf90_inquire_variable(NCID,VARID,VARNAME) )
  ELSE IF((VARID.EQ.0).AND.(TRIM(VARNAME).NE."")) THEN
    !GET VARIABLE ID NUMBER
    call check( nf90_inq_varid(NCID,TRIM(VARNAME),VARID) )
  END IF
  !GET VARIABLE NUMBER OF DIMENSIONS
  call check( nf90_inquire_variable(NCID,VARID,ndims=VARNDIMS) )
  !GET VARIABLE UNIT.
  IF(PRESENT(VARUNIT)) call check( nf90_get_att(NCID,VARID,"units",VARUNIT) )

  RETURN
 END SUBROUTINE GETVARINFO


 SUBROUTINE GETVARDIMSIZE(NCID,VARID,VARDIMSIZE)
  IMPLICIT NONE
  INTEGER(4), INTENT(IN)  :: NCID
  INTEGER(4), INTENT(IN)  :: VARID
  INTEGER(4), INTENT(OUT) :: VARDIMSIZE(:)

  !LOCAL VARIABLE
  INTEGER(4), ALLOCATABLE :: VARDIMID(:)
  INTEGER(4)              :: iDIMID

  ALLOCATE(VARDIMID(SIZE(VARDIMSIZE)))
  !GET DIMENSION IDENTIFICATION
  call check( nf90_inquire_variable(NCID,VARID,dimids=VARDIMID) )
  !GET DIMENSION SHAPE
  DO iDIMID=1,SIZE(VARDIMSIZE)
    call check( nf90_inquire_dimension(NCID,VARDIMID(iDIMID),len=VARDIMSIZE(iDIMID)) )
  END DO

  RETURN
 END SUBROUTINE GETVARDIMSIZE


!***************************************************!
! READ THE FIELDS AND DIMENSIONS FROM A NETCDF FILE !
!***************************************************!
!*****************!
! READ DIMENSIONS !
!*****************!
 SUBROUTINE GETDIMINFO(NCID,XVARID,XSIZE,DIMNAME,DIMUNIT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(IN)            :: NCID
  INTEGER(4),   INTENT(IN)            :: XVARID
  INTEGER(4),   INTENT(OUT)           :: XSIZE
  CHARACTER(*), INTENT(OUT), OPTIONAL :: DIMNAME
  CHARACTER(*), INTENT(OUT), OPTIONAL :: DIMUNIT

  !LOCAL VARIABLES
  INTEGER(4)                          :: XDIMID(1)

  !GET DIMENSION IDENTIFICATION
  call check( nf90_inquire_variable(NCID,XVARID,dimids=XDIMID) )
  !GET DIMENSION SIZE
  call check( nf90_inquire_dimension(NCID,XDIMID(1),len=XSIZE) )
  !GET DIMENSION NAME
  IF(PRESENT(DIMNAME)) call check( nf90_inquire_variable(NCID,XVARID,DIMNAME) )
  !GET DIMENSION UNIT.
  IF(PRESENT(DIMUNIT)) call check( nf90_get_att(NCID, XVARID,"units",DIMUNIT) )

  RETURN
 END SUBROUTINE GETDIMINFO

 SUBROUTINE i4READDIM(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4),   INTENT(OUT)          :: X1D(:)
  INTEGER(4),   INTENT(IN)           :: NCID
  INTEGER(4),   INTENT(IN)           :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

 !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE :: LX1D(:)
  INTEGER(4)                :: iXDIM

  IF(ALLOCATED(LX1D).EQV..FALSE.) ALLOCATE(LX1D(SIZE(X1D)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READDIM(NCID,XVARID,LX1D,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READDIM(NCID,XVARID,LX1D,DATASTART)
  ELSE
    CALL READDIM(NCID,XVARID,LX1D)
  END IF
  DO iXDIM=1,SIZE(X1D)
   X1D(iXDIM)=REAL(LX1D(iXDIM),4)
  END DO

  RETURN
 END SUBROUTINE i4READDIM

 SUBROUTINE r4READDIM(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),      INTENT(OUT)          :: X1D(:)
  INTEGER(4),   INTENT(IN)           :: NCID
  INTEGER(4),   INTENT(IN)           :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

 !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE :: LX1D(:)
  INTEGER(4)                :: iXDIM

  IF(ALLOCATED(LX1D).EQV..FALSE.) ALLOCATE(LX1D(SIZE(X1D)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READDIM(NCID,XVARID,LX1D,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READDIM(NCID,XVARID,LX1D,DATASTART)
  ELSE
    CALL READDIM(NCID,XVARID,LX1D)
  END IF
  DO iXDIM=1,SIZE(X1D)
   X1D(iXDIM)=REAL(LX1D(iXDIM),4)
  END DO

  RETURN
 END SUBROUTINE r4READDIM

 SUBROUTINE r8READDIM(NCID,XVARID,X1D,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),      INTENT(OUT)          :: X1D(:)
  INTEGER(4),   INTENT(IN)           :: NCID
  INTEGER(4),   INTENT(IN)           :: XVARID
  INTEGER(4),   INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  !GET DIMENSION ARRAY
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    call check( nf90_get_var(NCID,XVARID,X1D, start = (/DATASTART/), count = (/DATACOUNT/)) )
  ELSE IF(PRESENT(DATASTART)) THEN
    call check( nf90_get_var(NCID,XVARID,X1D, start = (/DATASTART/), count = (/SIZE(X1D)/)) )
  ELSE
    call check( nf90_get_var(NCID,XVARID,X1D) )
  END IF
 
  RETURN
 END SUBROUTINE r8READDIM


!*************************!
! READ 3D MULTIPLE FIELDS !
!*************************!
 SUBROUTINE i4READFLD4D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4), INTENT(OUT)          :: rfld(:,:,:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID(:)
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld(:,:,:,:)
  INTEGER(4)                       :: ifld,iXDIM,iYDIM,iZDIM
  INTEGER(4)                       :: MATDIMS4D(4)

  MATDIMS4D=SHAPE(rfld)
  ALLOCATE(Lrfld(MATDIMS4D(1),MATDIMS4D(2),MATDIMS4D(3),MATDIMS4D(4)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  DO iXDIM=1,MATDIMS4D(1)
   DO iYDIM=1,MATDIMS4D(2)
    DO iZDIM=1,MATDIMS4D(3)
     DO ifld=1,MATDIMS4D(4)
       rfld(iXDIM,iYDIM,iZDIM,ifld)=NINT(Lrfld(iXDIM,iYDIM,iZDIM,ifld),4)
     END DO
    END DO
   END DO
  END DO

  RETURN
 END SUBROUTINE i4READFLD4D

 SUBROUTINE r4READFLD4D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),    INTENT(OUT)          :: rfld(:,:,:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID(:)
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld(:,:,:,:)
  INTEGER(4)                       :: ifld,iXDIM,iYDIM,iZDIM
  INTEGER(4)                       :: MATDIMS4D(4)

  MATDIMS4D=SHAPE(rfld)
  ALLOCATE(Lrfld(MATDIMS4D(1),MATDIMS4D(2),MATDIMS4D(3),MATDIMS4D(4)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  DO iXDIM=1,MATDIMS4D(1)
   DO iYDIM=1,MATDIMS4D(2)
    DO iZDIM=1,MATDIMS4D(3)
     DO ifld=1,MATDIMS4D(4)
       rfld(iXDIM,iYDIM,iZDIM,ifld)=REAL(Lrfld(iXDIM,iYDIM,iZDIM,ifld),4)
     END DO
    END DO
   END DO
  END DO

  RETURN
 END SUBROUTINE r4READFLD4D

 SUBROUTINE r8READFLD4D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE

 !INPUT VARIABLES
  REAL(8),    INTENT(OUT)          :: rfld(:,:,:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID(:)
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

 !LOCAL VARIABLES
  INTEGER(4)                       :: MATDIMS4D(4)
  INTEGER(4), PARAMETER            :: NDIMS = 4
  INTEGER(4)                       :: start(NDIMS),count(NDIMS)
  INTEGER(4)                       :: ifld


  MATDIMS4D=SHAPE(rfld)

  !These settings tell netcdf to read one timestep of data.
  !(The setting of start(4) inside the loop below tells netCDF which timestep to read.)
  IF(PRESENT(DATACOUNT)) THEN
   count(1:NDIMS-1) = DATACOUNT
   count(NDIMS)     = 1
  ELSE
   count = (/ MATDIMS4D(1), MATDIMS4D(2), MATDIMS4D(3), 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(1:NDIMS-1) = DATASTART
   start(NDIMS)     = RECID
  ELSE
   start = (/ 1, 1, 1, RECID /)
  END IF

  !READ THE FIELD DATA
  DO ifld=1,MATDIMS4D(4)
   call check( nf90_get_var(ncid, FLDVARID(ifld), rfld(:,:,:,ifld), start = start, count = count) )
  END DO
  
  RETURN
 END SUBROUTINE r8READFLD4D


!**********************!
! READ 3D SINGLE FIELD !
!**********************!
 SUBROUTINE i4READFLD3D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4), INTENT(OUT)          :: rfld(:,:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld(:,:,:)
  INTEGER(4)                       :: iXDIM,iYDIM,iZDIM
  INTEGER(4)                       :: MATDIMS3D(3)

  MATDIMS3D=SHAPE(rfld)
  ALLOCATE(Lrfld(MATDIMS3D(1),MATDIMS3D(2),MATDIMS3D(3)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  DO iXDIM=1,MATDIMS3D(1)
   DO iYDIM=1,MATDIMS3D(2)
    DO iZDIM=1,MATDIMS3D(3)
     rfld(iXDIM,iYDIM,iZDIM)=NINT(Lrfld(iXDIM,iYDIM,iZDIM),4)
    END DO
   END DO
  END DO

  RETURN
 END SUBROUTINE i4READFLD3D

 SUBROUTINE r4READFLD3D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),    INTENT(OUT)          :: rfld(:,:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld(:,:,:)
  INTEGER(4)                       :: iXDIM,iYDIM,iZDIM
  INTEGER(4)                       :: MATDIMS3D(3)

  MATDIMS3D=SHAPE(rfld)
  ALLOCATE(Lrfld(MATDIMS3D(1),MATDIMS3D(2),MATDIMS3D(3)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  DO iXDIM=1,MATDIMS3D(1)
   DO iYDIM=1,MATDIMS3D(2)
    DO iZDIM=1,MATDIMS3D(3)
     rfld(iXDIM,iYDIM,iZDIM)=REAL(Lrfld(iXDIM,iYDIM,iZDIM),4)
    END DO
   END DO
  END DO

  RETURN
 END SUBROUTINE r4READFLD3D

 SUBROUTINE r8READFLD3D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),    INTENT(OUT)          :: rfld(:,:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  INTEGER(4)                       :: MATDIMS3D(3)
  INTEGER(4), PARAMETER            :: NDIMS = 4
  INTEGER(4)                       :: start(NDIMS),count(NDIMS)
  INTEGER(4)                       :: ifld


  !These settings tell netcdf to read one timestep of data.
  !(The setting of start(4) inside the loop below tells netCDF which timestep to read.)
  IF(PRESENT(DATACOUNT)) THEN
   count(1:NDIMS-1) = DATACOUNT
   count(NDIMS)     = 1
  ELSE
   MATDIMS3D=SHAPE(rfld)
   count = (/ MATDIMS3D(1), MATDIMS3D(2), MATDIMS3D(3), 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(1:NDIMS-1) = DATASTART
   start(NDIMS)     = RECID
  ELSE
   start = (/ 1, 1, 1, RECID /)
  END IF

  !READ FIELD DATA
  call check( nf90_get_var(ncid, FLDVARID, rfld, start = start, count = count) )
  
  RETURN
 END SUBROUTINE r8READFLD3D


!**********************!
! READ 2D SINGLE FIELD !
!**********************!
 SUBROUTINE i4READFLD2D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4), INTENT(OUT)          :: rfld(:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld(:,:)
  INTEGER(4)                       :: iXDIM,iYDIM
  INTEGER(4)                       :: MATDIMS2D(2)

  MATDIMS2D=SHAPE(rfld)
  ALLOCATE(Lrfld(MATDIMS2D(1),MATDIMS2D(2)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  DO iXDIM=1,MATDIMS2D(1)
   DO iYDIM=1,MATDIMS2D(2)
     rfld(iXDIM,iYDIM)=NINT(Lrfld(iXDIM,iYDIM),4)
   END DO
  END DO

  RETURN
 END SUBROUTINE i4READFLD2D

 SUBROUTINE r4READFLD2D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),    INTENT(OUT)          :: rfld(:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld(:,:)
  INTEGER(4)                       :: iXDIM,iYDIM
  INTEGER(4)                       :: MATDIMS2D(2)

  MATDIMS2D=SHAPE(rfld)
  ALLOCATE(Lrfld(MATDIMS2D(1),MATDIMS2D(2)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  DO iXDIM=1,MATDIMS2D(1)
   DO iYDIM=1,MATDIMS2D(2)
     rfld(iXDIM,iYDIM)=REAL(Lrfld(iXDIM,iYDIM),4)
   END DO
  END DO

  RETURN
 END SUBROUTINE r4READFLD2D

 SUBROUTINE r8READFLD2D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(8),    INTENT(OUT)          :: rfld(:,:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART(:),DATACOUNT(:)

  !LOCAL VARIABLES
  INTEGER(4)                       :: MATDIMS2D(2)
  INTEGER(4), PARAMETER            :: NDIMS = 3
  INTEGER(4)                       :: start(NDIMS),count(NDIMS)
  INTEGER(4)                       :: ifld


  !These settings tell netcdf to read one timestep of data.
  !(The setting of start(4) inside the loop below tells netCDF which timestep to read.)
  IF(PRESENT(DATACOUNT)) THEN
   count(1:NDIMS-1) = DATACOUNT
   count(NDIMS)     = 1
  ELSE
   MATDIMS2D=SHAPE(rfld)
   count = (/ MATDIMS2D(1), MATDIMS2D(2), 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(1:NDIMS-1) = DATASTART
   start(NDIMS)     = RECID
  ELSE
   start = (/ 1, 1, RECID /)
  END IF

  !READ FIELD DATA.
  call check( nf90_get_var(ncid, FLDVARID, rfld, start = start, count = count) )
  
  RETURN
 END SUBROUTINE r8READFLD2D


!**********************!
! READ 1D SINGLE FIELD !
!**********************!
 SUBROUTINE i4READFLD1D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4), INTENT(OUT)          :: rfld(:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld(:)
  INTEGER(4)                       :: iXDIM
  INTEGER(4)                       :: MATDIMS1D(1)

  MATDIMS1D=SIZE(rfld)
  ALLOCATE(Lrfld(MATDIMS1D(1)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  DO iXDIM=1,MATDIMS1D(1)
   rfld(iXDIM)=NINT(Lrfld(iXDIM),4)
  END DO

  RETURN
 END SUBROUTINE i4READFLD1D

 SUBROUTINE r4READFLD1D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),    INTENT(OUT)          :: rfld(:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld(:)
  INTEGER(4)                       :: iXDIM
  INTEGER(4)                       :: MATDIMS1D(1)

  MATDIMS1D=SIZE(rfld)
  ALLOCATE(Lrfld(MATDIMS1D(1)))
  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  DO iXDIM=1,MATDIMS1D(1)
   rfld(iXDIM)=REAL(Lrfld(iXDIM),4)
  END DO

  RETURN
 END SUBROUTINE r4READFLD1D

 SUBROUTINE r8READFLD1D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE

 !INPUT VARIABLES
  REAL(8),    INTENT(OUT)          :: rfld(:)
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  !LOCAL VARIABLES
  INTEGER(4)                :: MATDIMS1D(1)
  INTEGER(4), PARAMETER     :: NDIMS = 2
  INTEGER(4)                :: start(NDIMS),count(NDIMS)
  INTEGER(4)                :: ifld


  !These settings tell netcdf to read one timestep of data.
  !(The setting of start(4) inside the loop below tells netCDF which timestep to read.)
  IF(PRESENT(DATACOUNT)) THEN
   count(1:NDIMS-1) = DATACOUNT
   count(NDIMS)     = 1
  ELSE
   MATDIMS1D=SIZE(rfld)
   count = (/ MATDIMS1D(1), 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(1:NDIMS-1) = DATASTART
   start(NDIMS)     = RECID
  ELSE
   start = (/ 1, RECID /)
  END IF

  !READ FIELD DATA.
  call check( nf90_get_var(ncid, FLDVARID, rfld, start = start, count = count) )
  
  RETURN
 END SUBROUTINE r8READFLD1D


!**********************!
! READ 0D SINGLE FIELD !
!**********************!
 SUBROUTINE i4READFLD0D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  INTEGER(4), INTENT(OUT)          :: rfld
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld
  INTEGER(4)                       :: iXDIM
  INTEGER(4)                       :: MATDIMS1D

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  rfld=NINT(Lrfld,4)

  RETURN
 END SUBROUTINE i4READFLD0D

 SUBROUTINE r4READFLD0D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE
  REAL(4),    INTENT(OUT)          :: rfld
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  !LOCAL VARIABLES
  REAL(8),      ALLOCATABLE        :: Lrfld
  INTEGER(4)                       :: iXDIM
  INTEGER(4)                       :: MATDIMS1D

  IF(PRESENT(DATASTART).AND.PRESENT(DATACOUNT)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART,DATACOUNT)
  ELSE IF(PRESENT(DATASTART)) THEN
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld,DATASTART)
  ELSE
    CALL READFLD(NCID,RECID,FLDVARID,Lrfld)
  END IF
  rfld=REAL(Lrfld,4)

  RETURN
 END SUBROUTINE r4READFLD0D

 SUBROUTINE r8READFLD0D(NCID,RECID,FLDVARID,rfld,DATASTART,DATACOUNT)
  IMPLICIT NONE

 !INPUT VARIABLES
  REAL(8),    INTENT(OUT)          :: rfld
  INTEGER(4), INTENT(IN)           :: NCID
  INTEGER(4), INTENT(IN)           :: RECID
  INTEGER(4), INTENT(IN)           :: FLDVARID
  INTEGER(4), INTENT(IN), OPTIONAL :: DATASTART,DATACOUNT

  !LOCAL VARIABLES
  REAL(8)                   :: Lrfld(1)
  INTEGER(4)                :: MATDIMS1D
  INTEGER(4), PARAMETER     :: NDIMS = 1
  INTEGER(4)                :: start(NDIMS),count(NDIMS)
  INTEGER(4)                :: ifld


  !These settings tell netcdf to read one timestep of data.
  !(The setting of start(4) inside the loop below tells netCDF which timestep to read.)
  IF(PRESENT(DATACOUNT)) THEN
   count(NDIMS)     = 1
  ELSE
   count = (/ 1 /)
  END IF
  IF(PRESENT(DATASTART)) THEN
   start(NDIMS)     = RECID
  ELSE
   start = (/ RECID /)
  END IF

  !READ FIELD DATA.
  call check( nf90_get_var(ncid, FLDVARID, Lrfld, start = start, count = count) )
  rfld = Lrfld(1)
  
  RETURN
 END SUBROUTINE r8READFLD0D



!*************!
! ERROR CHECK !
!*************!
 SUBROUTINE CHECK(status)
    integer, intent ( in) :: status
    
    if(status.ne.nf90_noerr) then 
      print *, trim(nf90_strerror(status))
      stop "Stopped"
    end if
 END SUBROUTINE CHECK

 subroutine handle_err(status,VarID)
  integer, intent ( in) :: status
  integer, optional     :: VarID
  character(3)          :: cVarID

  if(present(VarID)) then
   if(VarID.LT.10) then
    cVarID=char(48+VarID)
   elseif (VarId.LT.100) then
    cVarID=char(48+(VarID/10))//char(48+MOD(VarID,10))
   elseif (VarId.GT.100) then
    cVarID=char(48+(VarID/100))//char(48+(MOD(VarID,100)/10))//char(48+MOD(MOD(VarID,100),10))
   end if
  end if
  if(status /= nf90_noerr) then
   if(present(VarID)) then
    print *, "(Error) Variable ID ", cVarID, " - ", trim(nf90_strerror(status))
   else
    print *, trim(nf90_strerror(status))
   end if
   !stop "Stopped"
    stop
  end if
 end subroutine handle_err

 FUNCTION I4NUM2STR(NUM)
  IMPLICIT NONE
  CHARACTER(10) :: I4NUM2STR
  INTEGER(4)    :: NUM

  IF((NUM/1000000000).GE.1) THEN
   WRITE(I4NUM2STR,'(I10)') NUM
  ELSEIF((NUM/100000000).GE.1) THEN
   WRITE(I4NUM2STR,'(I9)') NUM
  ELSEIF((NUM/10000000).GE.1) THEN
   WRITE(I4NUM2STR,'(I8)') NUM
  ELSEIF((NUM/1000000).GE.1) THEN
   WRITE(I4NUM2STR,'(I7)') NUM
  ELSEIF((NUM/100000).GE.1) THEN
   WRITE(I4NUM2STR,'(I6)') NUM
  ELSEIF((NUM/10000).GE.1) THEN
   WRITE(I4NUM2STR,'(I5)') NUM
  ELSEIF((NUM/1000).GE.1) THEN
   WRITE(I4NUM2STR,'(I4)') NUM
  ELSEIF((NUM/100).GE.1) THEN
   WRITE(I4NUM2STR,'(I3)') NUM
  ELSEIF((NUM/10).GE.1) THEN
   WRITE(I4NUM2STR,'(I2)') NUM
  ELSE
   WRITE(I4NUM2STR,'(I1)') NUM
  ENDIF

  RETURN
 END FUNCTION I4NUM2STR


END MODULE RDSVNETCDF
