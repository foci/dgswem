#include <functional>
#include <iostream>
#include <string>
#include <stdio.h>
#include <sstream>
#include <cmath>

extern "C"
{

  /*
   * define_plot_var defines the lambda which determines how the derived variable is computed. If you
   *                 want to define a custom derived variable I recommend using the custom field.
   *                 All of the arguments are nodal values, so you just have to enter the formula
   *                 and the plotter will take care of the rest.
   */

  std::function<double( const double&, const double&, const double&, const double&)> define_plot_var(char *plot_type)
  {
    if ( *plot_type == 'ze' ) {
      return [](const double& ze, const double& qx, const double& qz, const double& b)
	{
	  return ze;
	}; }
    else if ( *plot_type == 'h' )
      return [](const double& ze, const double& qx, const double& qz, const double& b)
	{
	  return ze + b;
	}; }
  else if ( *plot_type == 'b' )
    return [](const double& ze, const double& qx, const double& qz, const double& b)
      {
	return b;
      }; }
 else if ( *plot_type == 'qx' )
   return [](const double& ze, const double& qx, const double& qz, const double& b)
     {
       return qx;
     }; }
  else if ( *plot_type == 'qy' )
    return [](const double& ze, const double& qx, const double& qz, const double& b)
      {
	return qy;
      }; }
  else if ( *plot_type == 'u' )
    return [](const double& ze, const double& qx, const double& qz, const double& b)
      {
	if ( ze + b < 10*std::numeric_limits<double>::epsilon()*std::abs(x+y) )
	  return 0;
	else
	  return qx/(ze + b);
      }; }
  else if ( *plot_type == 'v' )
    get_val = [](const double& ze, const double& qx, const double& qz, const double& b)
      {
	if ( ze + b < 10*std::numeric_limits<double>::epsilon()*std::abs(x+y) )
	  return 0;
	else
	  return qy/(ze + b);
      }; }
  else if ( *plot_type == 'custom' )
    get_val = [](const double& ze, const double& qx, const double& qz, const double& b)
      {
	return ze;}; }
  else {
    std::cerr << "Error: invalid plot type selected" << std::endl;
    return [](const double& ze, const double& qx, const double& qz, const double& b){ return -1;}
  }
}

  void write_vtu(double *Qout, int cycle, int procid, int cells, double **x, double **y, int p_interp, double **Interpout, double **Triout, int K_interp, char *plot_type)
{

  std::function<double(const double&, const double&, const double&, const double&)> get_val = ;


  bool disc = true;
  
  datafloat **xout = BuildMatrix(p_interp, cells);
  datafloat **yout = BuildMatrix(p_interp, cells);
  datafloat **pout = BuildMatrix(p_interp, cells);
  //First compute the output grid
  for(int p=0;p<p_interp;++p){
    for(int k=0;k<cells;++k){
      
      xout[p][k] = 0.0;
      yout[p][k] = 0.0;
      pout[p][k] = 0.0;

      for(int n=0;n<p_Np;++n){
	
	xout[p][k] = xout[p][k] + Interpout[p][n] * x[k][n];
	yout[p][k] = yout[p][k] + Interpout[p][n] * y[k][n];
	datafloat ph = Qout[n + field_id*p_Np + k*p_Np*p_Nfields];
	pout[p][k] = pout[p][k] + Interpout[p][n] * ph;
      }

      //std::cout << "xout[" << p << "][" << k << "] = " << xout[p][k] << std::endl;
      //int ll; std::cin >> ll;

    }
  }

  char buffer1[6]; std::string buf1;
  snprintf(buffer1, 6, "%05d", cycle);
  char buffer2[6]; std::string buf2;
  snprintf(buffer2, 6, "%05d", procid);

  std::stringstream ss; std::stringstream ss2;

  ss << buffer1;
  ss >> buf1;
  ss2 << buffer2;
  ss2 >> buf2;
  
  const std::string filename = ("output/P/P-" + buf2 + "." + buf1 + ".vtu");
  
  std::ofstream output (filename.c_str());

  output << "<?xml version=\"1.0\" ?> \n";
  output << "<!--\n";
  output << "# Generated by ArcSyn3sis";
  output << "\n-->\n";
  output << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\"";
  //output << " compressor=\"vtkZLibDataCompressor\"";
  //output << " byte_order=\"LittleEndian\"";
  output << " byte_order=\"BigEndian\"";
  output << ">";
  output << '\n';
  output << "  <UnstructuredGrid>";
  output << '\n';
  output << "    <Piece NumberOfPoints=\"" << p_interp*cells
	 <<"\" NumberOfCells=\"" << K_interp << "\">\n";
  output << "      <Points>\n";
  output << "        <DataArray type=\"Float64\" NumberOfComponents=\"3\" Format=\""
	 << "ascii" << "\">\n"; //As in 3D, x y z
  
  //double z = 0.0;
  for(int k=0;k<cells;++k){
    for(int p=0;p<p_interp;++p){
      
      output << std::setprecision(14);
      output << "        " << xout[p][k] << " ";
      output << "        " << yout[p][k] << " ";
      output << "        " << "0.0"      << " ";
      output << '\n';

    }
  }

  output << "        </DataArray>\n";
  output << "      </Points>\n";
  output << "      <Cells>\n";
  output << "        <DataArray type=\"Float64\" Name=\"connectivity\" Format=\""
         << "ascii" << "\">\n";
  
  for(int k=0;k<K_interp;++k){
    
    output << "        " << Triout[k][0]-1 << " ";
    output << "        " << Triout[k][1]-1 << " ";
    output << "        " << Triout[k][2]-1 << " ";
    output << "        " << '\n';
    
  }
  
  output << "        </DataArray>\n";
  output << "        <DataArray type=\"Int64\" Name=\"offsets\" Format=\""
         << "ascii" << "\">\n";
  
  for(int k=0;k<K_interp;++k){
    int j=k+1;
    j*=3;
    output << j << " ";
  }
  output << "\n";
  output << "        </DataArray>\n";
  output << "        <DataArray type=\"Int64\" Name=\"types\" Format=\""
         << "ascii" << "\">\n";
  
  for(int k=0;k<K_interp;++k){
    int j = 5;
    output << j << " ";
  }
  
  output << "\n";
  output << "        </DataArray>\n";
  output << "      </Cells>\n";
  output << "      <PointData Scalars=\"scalars\">\n";
  output << "        <DataArray type=\"Float64\" Name=\"Pressure\" Format=\""
         << "ascii" << "\">\n";

  //For fully discontinuous output

  if (disc){
    
    for(int k=0;k<cells;++k){
      for(int p=0;p<p_interp;++p){
	
	output << "        " << pout[p][k] << " ";
	output << '\n';
	
      }
    }
  }
  else{
/*    
    //For continuous output
    datafloat eps = 1e-5;
    for(int k=0;k<cells;++k){
      for(int p=0;p<p_interp;++p){
	
	datafloat pcont = pout[p][k];
	int niter = 1;
	
	for(int k2=0;k2<cells;++k2){
	  for(int p2=0;p2<p_interp;++p2){
	    
	    if ( ( std::abs(double(xout[p][k] - xout[p2][k2])) < eps && std::abs(double(yout[p][k] - yout[p2][k2])) < eps) && (p!=p2 || k!=k2) ){

	      pcont +=  pout[p2][k2];
	      niter = niter+1;

	      //std::cout << "test" << std::endl;
	      
	    }
	  }
	}
	output << "        " << pcont/niter << " ";
	output << '\n';
      }
    }
    }*/
  
  output << "        </DataArray>\n";
  output <<  "      </PointData>\n";
  output << "    </Piece>\n";
  output << "  </UnstructuredGrid>\n";
  output << "</VTKFile>";

}

}
